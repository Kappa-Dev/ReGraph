
Tutorial
========
* :ref:`tutorial_part1`
    * :ref:`installation`
    * :ref:`simple_rewriting`
        * :ref:`graph_creation`
        * :ref:`advanced_attributes`
        * :ref:`rewiting_rules`
* :ref:`tutorial_part2`
    * :ref:`hierarchy_tutorial`
        * :ref:`hierarchy_creation`
        * :ref:`rewriting_in_hierarchy`


.. _tutorial_part2:

Tutorial: part 2
================


If you missed the part of the ReGraph tutorial about primitive graph transformations, advanced graph attributes and rewriting rules, go back to :ref:`tutorial_part1`.


.. _hierarchy_tutorial:

---------
Hierarchy
---------

A graph hierarchy is a directed acyclic graph where nodes are graphs with attributes and edges are
homomorphisms representing graph typing in the system. This construction provides means
for mathematically robust procedures of propagation of changes (expressed through graph rewriting
rules) on any level of the hierarchy, up to all the graphs which are transitively typed by the graph
subject to rewriting. In the following section we give a simple example of such hierarchy and its
functionality implemented in ReGraph.

.. _hierarchy_creation:

^^^^^^^^^^^^^^^^^^
Hierarchy creation
^^^^^^^^^^^^^^^^^^
Create an empty hierarchy and add graphs to the hierarchy: ::
    
    import networkx as nx

    from regraph import Hierarchy, plot_graph, primitives


    hierarchy = Hierarchy()

    t = nx.DiGraph()
    primitives.add_nodes_from(
        t, ["agent", "action", "state"])
    primitives.add_edges_from(
        t, 
        [
            ("agent", "agent"),
            ("state", "agent"),
            ("agent", "action"),
            ("action", "state")
        ])

    g = nx.DiGraph()
    primitives.add_nodes_from(
        g,
        ["protein", "region",
         "activity", "mod"])
    primitives.add_edges_from(
        g,
        [
            ("region", "protein"),
            ("activity", "protein"),
            ("activity", "region"),
            ("protein", "mod"),
            ("region", "mod"),
        ])

    hierarchy.add_graph("T", t)
    hierarchy.add_graph("G", g)
    

>>> plot_graph(hierarchy.graph["T"])

.. image:: _images/ex1_meta_meta_model.png

>>> plot_graph(hierarchy.graph["G"])

.. image:: _static/ex1_meta_model.png


>>> hierarchy.graphs()
['T', 'G']

Add typing of the graph `G` by `T`: ::
    
    mapping = {
        "protein": "agent",
        "region": "agent",
        "activity": "state",
        "mod": "action"
    }
    hierarchy.add_typing("G", "T", mapping)

>>> hierarchy.typing["G"]["T"]
{'activity': 'state', 'mod': 'action', 'protein': 'agent', 'region': 'agent'}

You can check typing of a particular node of a graph, for example:

>>> hierarchy.node_type("G", "region")
{'T': 'agent'}

Create another graph, let's call it `model`, and type it by `G` ::
    
    model = nx.DiGraph()
    primitives.add_nodes_from(
        model,
        ["A", "R", "B", "B_activity",
         "A_activity", "activation"])
    primitives.add_edges_from(model, [
        ("R", "A"),
        ("R", "activation"),
        ("activation", "B_activity"),
        ("B_activity", "B"),
        ("activation", "A_activity"),
        ("A_activity", "A")
    ])
    hierarchy.add_graph("model", model)

    mapping = {
        "A": "protein",
        "R": "region",
        "B": "protein",
        "B_activity": "activity",
        "A_activity": "activity",
        "activation": "mod"
    }
    hierarchy.add_typing("model", "G", mapping)

    plot_graph(hierarchy.graph["model"])

.. image:: _static/ex1_model.png

>>> hierarchy.typings()
[('G', 'T'), ('model', 'G')]

Remove a node from the hierarchy and reconnect its predecessors with its successors:

>>> hierarchy.remove_node("G", reconnect=True)
>>> hierarchy.typings()
[('model', 'T')]
>>> hierarchy.typing["model"]["T"]
{'A': 'agent',
 'B': 'agent',
 'B_activity': 'state',
 'A_activity': 'state',
 'R': 'agent',
 'activation': 'action'}

Graph hierarchy allows to accommodate binary symmetric relations on graphs.
Consider the following graph:

::

    catalysis = nx.DiGraph()
    primitives.add_nodes_from(
        catalysis,
        ["enzyme", "substrate",
         "mod", "mod_state"]
    )
    primitives.add_edges_from(catalysis, [
        ("enzyme", "mod"),
        ("mod", "mod_state"),
        ("mod_state", "substrate")
    ])

    hierarchy.add_graph("catalysis", catalysis)

    plot_graph(hierarchy.graph["catalysis"])


.. image:: _static/ex1_catalysis.png

Create a relation between graph `model` and graph `catalysis`: ::

    relation = {
        "A": {"enzyme", "substrate"},
        "B": "substrate",
        "B_activity": "mod_state",
        "A_activity": "mod_state",
        "activation": "mod"
    }
    hierarchy.add_relation('model', 'catalysis', relation)

Note that in a relation between two graphs a node from one graph can be related to a set of nodes
from another graph (in our example node `A` in the graph `model` is related to both
`enzyme` and `substrate` from the graph `catalysis`):

>>> hierarchy.relation['model']['catalysis']
{'A': {'enzyme', 'substrate'},
 'A_activity': {'mod_state'},
 'B': {'substrate'},
 'B_activity': {'mod_state'},
 'activation': {'mod'}}
>>> hierarchy.relation['catalysis']['model']
{'enzyme': {'A'},
 'mod': {'activation'},
 'mod_state': {'A_activity', 'B_activity'},
 'substrate': {'A', 'B'}}

This example can be found in the following :download:`script <_static/tutorial2_ex1.py>`.

.. _rewriting_in_hierarchy:

^^^^^^^^^^^^^^^^^^^^^^^^^^
Rewriting in the hierarchy
^^^^^^^^^^^^^^^^^^^^^^^^^^

This section of the tutorial covers rewriting in a graph hierarchy. Rewriting a single graph in
a hierarchy triggers a set of updates to other graphs and homomorphisms. Here we give a simple example and
illustrate a usecase of such rewriting and how it can be peformed using ReGraph.

First, let's start from creating another hierarchy similar to the one in the previous example: ::
    
    import networkx as nx

    from regraph import Hierarchy, Rule, RewritingError
    from regraph import primitives
    from regraph import plotting


    hierarchy = Hierarchy()
    
    # Initialize graphs
    colors = nx.DiGraph()
    primitives.add_nodes_from(
        colors, ["red", "blue"])
    primitives.add_edges_from(
        colors,
        [("red", "red"), ("blue", "red"), ("red", "blue")])
    
    mmm = nx.DiGraph()
    primitives.add_nodes_from(
        mmm, ["component", "state", "action"])

    primitives.add_edges_from(
        mmm,
        [("component", "action"),
         ("component", "component"),
         ("state", "component"),
         ("action", "state")])

    mm = nx.DiGraph()
    primitives.add_nodes_from(
        mm, ["gene", "residue", "state", "mod"])
    primitives.add_edges_from(
        mm,
        [("residue", "gene"),
         ("state", "gene"),
         ("state", "residue"),
         ("mod", "state"),
         ("gene", "mod")
        ])

    action_graph = nx.DiGraph()
    primitives.add_nodes_from(
        action_graph, ["A", "A_res_1", "p", "B", "mod"])

    primitives.add_edges_from(
        action_graph,
        [("A_res_1", "A"),
         ("p", "A_res_1"),
         ("mod", "p"),
         ("B", "mod")])

    nugget_1 = nx.DiGraph()
    primitives.add_nodes_from(
        nugget_1, ["A", "A_res_1", "p", "B", "mod"])

    primitives.add_edges_from(
        nugget_1,
        [("A_res_1", "A"),
         ("p", "A_res_1"),
         ("mod", "p"),
         ("B", "mod")])

    # Add graphs to the hierarchy
    hierarchy.add_graph("colors", colors)
    hierarchy.add_graph("mmm", mmm)
    hierarchy.add_graph("mm", mm)
    hierarchy.add_graph("ag", action_graph)
    hierarchy.add_graph("n1", nugget_1)

    # Add typings to the hierarchy
    hierarchy.add_typing(
        "mm", "mmm",
        {
            "gene" : "component",
            "residue": "component",
            "state": "state",
            "mod": "action"
        })
    hierarchy.add_typing(
        "mm", "colors",
        {
            "gene": "red",
            "residue": "red",
            "state": "red",
            "mod": "blue"
        })
    hierarchy.add_typing(
        "ag", "mm",
        {
            "A": "gene",
            "B": "gene",
            "A_res_1": "residue",
            "mod" : "mod",
            "p": "state"
        })
    hierarchy.add_typing(
        "n1", "ag",
        dict((n, n) for n in nugget_1.nodes()))

Let's plot the graphs of the hierarchy that we've just created:

>>> plotting.plot_graph(hierarchy.graph["colors"])

.. image:: _static/ex2_colors.png

>>> plotting.plot_graph(hierarchy.graph["mmm"])

.. image:: _static/ex2_mmm.png

>>> plotting.plot_graph(hierarchy.graph["mm"])

.. image:: _static/ex2_mm.png

>>> plotting.plot_graph(hierarchy.graph["ag"])

.. image:: _static/ex2_ag.png

>>> plotting.plot_graph(hierarchy.graph["n1"])

.. image:: _static/ex2_n1.png

Now, we would like to rewrite the graph `n1` with the rule and the instance
defined below: ::

    p = nx.DiGraph()
    primitives.add_nodes_from(p, ["B"])

    l = nx.DiGraph()
    primitives.add_nodes_from(l, ["B"])

    r = nx.DiGraph()
    primitives.add_nodes_from(r, ["B", "B_res_1", "X", "Y"])
    primitives.add_edge(r, "B_res_1", "B")

    rule = Rule(p, l, r)
    plotting.plot_rule(rule)

    instance = {"B": "B"}
    plotting.plot_instance(
        hierarchy.graph["n1"], rule.lhs, instance,
        title="Graph 'n1' with the instance of a pattern highlighted")

.. image:: _static/ex2_rule.png
.. image:: _static/ex2_n1_instance.png

As can be seen on the figures below, our rule adds three new nodes to the graph `n1`
(i.e., 'B_res_1', 'X', 'Y') and connects with an edge 'B' (of the initial pattern)
and 'B_res_1'.

We can also define a typing for new nodes that will be created by the rule, and it can be
done by providing a typing of the right-hand side of the rule by hierarchy graphs:

::

    rhs_typing = {
        "mm": {"B_res_1": "residue"},
        "mmm": {"X": "component"},
        "colors": {"Y": "red"}
    }

Rewrite `n1` with the rule:

>>> _, rhs = hierarchy.rewrite("n1", rule, instance, rhs_typing=rhs_typing, strict=False)

Let's have a look on the changes to the hierarchy that were triggered by the rewriting:

>>> plotting.plot_instance(hierarchy.node["n1"].graph, rule.rhs, rhs_instance)

.. image:: _static/ex2_n1_result1_instance.png

On the figure above we can see that we successfully created new nodes in `n1`. Now let us 
observe the changes in `ag`:

>>> plotting.plot_graph(hierarchy.graph["ag"])

.. image:: _static/ex2_ag_result1.png

>>> hierarchy.typing["n1"]["ag"]
{'A': 'A',
 'A_res_1': 'A_res_1',
 'B': 'B',
 'B_res_1': 'B_res_1',
 'X': 'X',
 'Y': 'Y',
 'mod': 'mod',
 'p': 'p'}